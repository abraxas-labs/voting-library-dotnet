// (c) Copyright 2022 by Abraxas Informatik AG
// For license information see LICENSE file

using System;
using System.Collections.Generic;
using System.Linq;
using Voting.Lib.VotingExports.Exceptions;
using Voting.Lib.VotingExports.Models;
using Voting.Lib.VotingExports.Repository.Ausmittlung;
using Voting.Lib.VotingExports.Repository.Basis;

namespace Voting.Lib.VotingExports.Repository;

/// <summary>
/// Provides access to all defined templates.
/// </summary>
public static class TemplateRepository
{
    private static readonly IReadOnlyCollection<TemplateModel> Templates =
        AusmittlungCsvProportionalElectionTemplates.All
            .Concat(AusmittlungCsvProportionalElectionUnionTemplates.All)
            .Concat(AusmittlungWabstiCTemplates.All)
            .Concat(AusmittlungPdfVoteTemplates.All)
            .Concat(AusmittlungPdfMajorityElectionTemplates.All)
            .Concat(AusmittlungPdfContestTemplates.All)
            .Concat(AusmittlungPdfProportionalElectionTemplates.All)
            .Concat(AusmittlungXmlVoteTemplates.All)
            .Concat(AusmittlungXmlMajorityElectionTemplates.All)
            .Concat(AusmittlungXmlProportionalElectionTemplates.All)
            .Concat(BasisXmlContestTemplates.All)
            .Concat(BasisXmlMajorityElectionTemplates.All)
            .Concat(BasisXmlProportionalElectionTemplates.All)
            .Concat(BasisXmlVoteTemplates.All)
            .ToList();

    private static readonly IReadOnlyDictionary<VotingApp, IReadOnlyCollection<TemplateModel>> ByGenerator = Templates
        .GroupBy(x => x.GeneratedBy)
        .ToDictionary(x => x.Key, x => (IReadOnlyCollection<TemplateModel>)x.OrderBy(y => y.Key).ToList());

    private static readonly IReadOnlyDictionary<(VotingApp, EntityType), IReadOnlyCollection<TemplateModel>> ByGeneratorAndEntityType =
        Templates
            .GroupBy(x => (x.GeneratedBy, x.EntityType))
            .ToDictionary(x => x.Key, x => (IReadOnlyCollection<TemplateModel>)x.OrderBy(y => y.Key).ToList());

    private static readonly IReadOnlyDictionary<string, TemplateModel> ByKey =
        Templates.ToDictionary(x => x.Key);

    static TemplateRepository()
    {
        foreach (var template in Templates)
        {
            template.Validate();
        }
    }

    /// <summary>
    /// Returns a template by its key.
    /// </summary>
    /// <param name="key">The key to look up the template for.</param>
    /// <returns>The found template.</returns>
    /// <exception cref="TemplateNotFoundException">If a template cannot be found.</exception>
    public static TemplateModel GetByKey(string key)
    {
        if (!ByKey.TryGetValue(key, out var template))
        {
            throw new TemplateNotFoundException(key);
        }

        return template;
    }

    /// <summary>
    /// Returns all templates which are generated by a specific app.
    /// </summary>
    /// <param name="generatedBy">The app, which generates the report.</param>
    /// <returns>The found templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetByGenerator(VotingApp generatedBy)
    {
        return ByGenerator.TryGetValue(generatedBy, out var templates)
            ? templates
            : Array.Empty<TemplateModel>();
    }

    /// <summary>
    /// Returns all templates which are generated by a specific app and have a specified entity type.
    /// </summary>
    /// <param name="generatedBy">The app, which generates the report.</param>
    /// <param name="entityType">The entity type.</param>
    /// <returns>The found templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetByGeneratorAndEntityType(VotingApp generatedBy, EntityType entityType)
    {
        return ByGeneratorAndEntityType.TryGetValue((generatedBy, entityType), out var templates)
            ? templates
            : Array.Empty<TemplateModel>();
    }

    /// <summary>
    /// Resolves counting circle templates.
    /// </summary>
    /// <param name="generatedBy">Voting app, which generates this export.</param>
    /// <param name="entityType">The entity type.</param>
    /// <param name="doiType">The type of the domain of influence.</param>
    /// <returns>The resolved templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetCountingCircleResultTemplates(
        VotingApp generatedBy,
        EntityType entityType,
        DomainOfInfluenceType doiType)
    {
        return GetTemplates(
            generatedBy,
            entityType,
            t => t.ResultType == ResultType.CountingCircleResult && (!t.DomainOfInfluenceType.HasValue || t.DomainOfInfluenceType == doiType));
    }

    /// <summary>
    /// Resolves templates for political businesses.
    /// </summary>
    /// <param name="generatedBy">Voting app, which generates this export.</param>
    /// <param name="entityType">The entity type.</param>
    /// <param name="doiType">The type of the domain of influence.</param>
    /// <returns>The resolved templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetPoliticalBusinessResultTemplates(
        VotingApp generatedBy,
        EntityType entityType,
        DomainOfInfluenceType doiType)
    {
        return GetTemplates(
            generatedBy,
            entityType,
            t => t.ResultType == ResultType.PoliticalBusinessResult
                 && t.EntityType == entityType
                 && (!t.DomainOfInfluenceType.HasValue || t.DomainOfInfluenceType == doiType));
    }

    /// <summary>
    /// Resolves templates for multiple political businesses.
    /// </summary>
    /// <param name="generatedBy">Voting app, which generates this export.</param>
    /// <returns>The resolved templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetMultiplePoliticalBusinessesResultTemplates(VotingApp generatedBy)
    {
        return GetTemplates(
            generatedBy,
            null,
            t => t.ResultType == ResultType.MultiplePoliticalBusinessesResult);
    }

    /// <summary>
    /// Resolves templates for multiple political businesses counting circle results.
    /// </summary>
    /// <param name="generatedBy">Voting app, which generates this export.</param>
    /// <returns>The resolved templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetMultiplePoliticalBusinessesCountingCircleResultTemplates(VotingApp generatedBy)
    {
        return GetTemplates(
            generatedBy,
            null,
            t => t.ResultType == ResultType.MultiplePoliticalBusinessesCountingCircleResult);
    }

    /// <summary>
    /// Resolves templates for political business unions.
    /// </summary>
    /// <param name="generatedBy">Voting app, which generates this export.</param>
    /// <param name="entityType">The entity type.</param>
    /// <returns>The resolved templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetPoliticalBusinessUnionResultTemplates(
        VotingApp generatedBy,
        EntityType entityType)
    {
        return GetTemplates(
            generatedBy,
            entityType,
            t => t.ResultType == ResultType.PoliticalBusinessUnionResult);
    }

    /// <summary>
    /// Resolves templates for contests.
    /// </summary>
    /// <param name="generatedBy">Voting app, which generates this export.</param>
    /// <returns>The resolved templates.</returns>
    public static IReadOnlyCollection<TemplateModel> GetContestTemplates(VotingApp generatedBy)
    {
        return GetByGeneratorAndEntityType(
            generatedBy,
            EntityType.Contest);
    }

    private static IReadOnlyCollection<TemplateModel> GetTemplates(
        VotingApp generatedBy,
        EntityType? entityType,
        Func<TemplateModel, bool>? predicate)
    {
        var templates = entityType.HasValue
            ? GetByGeneratorAndEntityType(generatedBy, entityType.Value)
            : GetByGenerator(generatedBy);

        if (predicate == null)
        {
            return templates;
        }

        return templates
            .Where(predicate)
            .ToList();
    }
}
